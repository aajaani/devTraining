awesomeâ€”hereâ€™s a **text-only, human-readable â€œflowchartâ€** of your whole app. itâ€™s organized like a subway map you can *read out loud* to the TA. no graphics, just clean structure, arrows, and short blurbs.

---

# legend

* **\[file]** â†’ main purpose
* `function()` â†’ what it does
* â†’ **calls** â†’ next hop
* â‡¦ **returns** â†’ what comes back
* âš™ **validates / enforces**
* ğŸ“¦ **persists / stores**

---

# birdâ€™s-eye lanes

```
Frontend (Angular)        â†’   FastAPI Routes & DI         â†’    Services & Repos                â†’   Storage / External
app.component.*                main.py (routes, startup)        posts_service.py, repo.py            PostgreSQL, MinIO
post.service.ts                dependencies.py (DI, MinIO)      schemas, ORM, config
proxy.conf.json                core/exceptions.py               db/models.py, db/database.py
```

---

# component atlas (who uses whom)

## frontend

* **`src/app/app.component.ts/html/css`**

  * collects inputs; shows posts & images; shows manual-dismiss error popup
  * â†’ calls **`PostService`** for all network actions

* **`src/app/post.service.ts`**

  * `getPosts()` â†’ **GET** `/post`
  * `createPost({title,post,username?,image?})` â†’ **POST** `/post` as **FormData** (so image is optional)
  * `upvote(id)` / `downvote(id)` â†’ **POST** `/update-post-score` `{ post_id, score_increase: Â±1 }`
  * also maps images: `image_url = /image/{hash}`

* **`src/app/post.model.ts`**

  * TS interface mirroring backend JSON: `{ id, title, post, score, username, image_hash? }`

* **`proxy.conf.json`**

  * proxies `/post`, `/update-post-score`, `/image/*` â†’ `http://localhost:8000` (no CORS pain in dev)

---

## backend: routing, DI, error shape

* **`backend/main.py`**

  * **startup (`lifespan`)**: `create_tables()` + `ensure_bucket()` (idempotent)
  * **routes**

    * `GET /post` â†’ list posts
    * `POST /post` â†’ create post (Form fields: `title`, `post`, `username?`; File: `image?`)
    * `POST /update-post-score` â†’ vote `{ post_id, score_increase }`
    * `GET /image/{hash}` â†’ stream bytes from MinIO
  * uses **`Depends(get_service(PostService))`** to inject a ready service (with DB session + repo)

* **`backend/dependencies.py`**

  * builds one **MinIO client**, `ensure_bucket()`, `get_minio()`
  * `get_service(ServiceType)` â†’ tiny DI: constructs a service, wiring its repository with the request-scoped DB session

* **`backend/core/exceptions.py`**

  * `BaseCustomException(...)` â†’ unified error body:

    ```json
    { "detail": { "user_message": "...", "internal_message": "..." } }
    ```
  * frontend shows `user_message` in the popup (manual close; no auto-dismiss)

---

## backend: services, repositories, contracts, ORM

* **`backend/services/posts_service.py`**

  * `add_post(req, image?)`

    * if image: `_compute_sha256(file)` â†’ **hash**, then `_upload_to_minio(image)` â†’ ğŸ“¦ MinIO `images/{hash}`
    * â†’ `repo.create_post(req, image_hash)`
    * â‡¦ returns the created row (as ORM model serialized by FastAPI)
  * `get_all_posts()` â†’ `repo.get_all_posts()`
  * `update_post_score(req)` â†’ `repo.update_post_score(req)`

* **`backend/repositories/post_repository.py`**

  * `create_post(req, image_hash)` â†’ **INSERT** row â†’ **COMMIT**
  * `get_all_posts()` â†’ **SELECT** `*` from `posts`
  * `update_post_score(req)` â†’ **single atomic SQL**

    ```
    UPDATE posts
    SET score = score + :inc
    WHERE id = :id
    ```

    * avoids race-condition â€œlost updatesâ€ during concurrent votes
    * then **reads** and returns the updated row

* **`backend/schemas/requests.py`** (Pydantic)

  * `AddNewPostRequest`: âš™ `title` **required**, `â‰¤100`; `post` **required**; `username` default `"anonymous"`
  * `UpdatePostScoreRequest`: âš™ `post_id: int`; `score_increase âˆˆ {+1,âˆ’1}`

* **`backend/db/models.py`**

  * `SavedPost` ORM: `id`, `title NOT NULL`, `username NOT NULL default 'anonymous'`, `post`, `score default 0`, `image_hash?`

* **`backend/db/database.py`**

  * builds **SQLAlchemy engine** + **SessionLocal**
  * `get_db()` â†’ yields a request-scoped session to DI
  * `create_tables()` â†’ executes `db/db_init/init.sql` (idempotent create)

* **`backend/config.py`**

  * environment-driven settings for Postgres + MinIO (with sensible local defaults)

---

## persistence / external services

* **PostgreSQL** (Docker named volume)

  * ğŸ“¦ stores rows in `posts` â€” all data and scores survive restarts
  * **atomic** `score = score + inc` happens here

* **MinIO** (S3-compatible; Docker named volume)

  * ğŸ“¦ stores images under `images/{sha256}`
  * `GET /image/{hash}` streams object bytes back to the browser

---

# end-to-end flows (call chains with arrows)

## 1) create a post (with optional image)

```
User (browser)
  â†“ fills form (title, post, username?, image?)
Angular app.component
  â†’ PostService.createPost(FormData)
  â†’ POST /post  (via proxy.conf to FastAPI)
FastAPI main.py (POST /post)
  âš™ validates with AddNewPostRequest (title required, â‰¤100)
  â†’ PostService.add_post(req, image?)
    â†’ (if image) _compute_sha256(file) â†’ _upload_to_minio(image) â†’ ğŸ“¦ MinIO images/{hash}
    â†’ PostRepository.create_post(req, image_hash) â†’ ğŸ“¦ PostgreSQL INSERT + COMMIT
    â‡¦ created ORM row
  â‡¦ JSON post (includes image_hash if present)
Angular PostService
  â‡¦ post â†’ app.component reloads list (fresh GET /post)
UI updates immediately
```

## 2) list posts (page load or after actions)

```
app.component.ngOnInit / after action
  â†’ PostService.getPosts()
  â†’ GET /post
FastAPI main.py (GET /post)
  â†’ PostService.get_all_posts()
    â†’ PostRepository.get_all_posts() â†’ ğŸ“¦ PostgreSQL SELECT *
  â‡¦ array of posts
Angular maps image_hash â†’ image_url (/image/{hash}), renders list
```

## 3) upvote / downvote

```
User clicks â–² / â–¼
Angular app.component
  â†’ PostService.upvote(id) OR downvote(id)
  â†’ POST /update-post-score  { post_id, score_increase: +1 | -1 }
FastAPI main.py
  âš™ validates with UpdatePostScoreRequest
  â†’ PostService.update_post_score(req)
    â†’ PostRepository.update_post_score(req)
       â†’ ğŸ“¦ PostgreSQL  UPDATE score = score + :inc  (atomic)
       â†’ SELECT updated row
  â‡¦ updated post JSON
Angular reloads list (ensures â€œmost current contentâ€)
```

## 4) fetch & display image

```
Angular template renders <img src="/image/{hash}">
  â†’ GET /image/{hash}
FastAPI main.py
  â†’ dependencies.get_minio().get_object(bucket, "images/{hash}")
  â‡¦ StreamingResponse(bytes, content-type guessed)
Browser shows the image inline
```

## 5) startup & persistence (what happens when you restart)

```
uvicorn main:app starts
  â†’ lifespan handler:
     â†’ db.database.create_tables()   (idempotent; no data loss)
     â†’ dependencies.ensure_bucket()  (idempotent)
Containers restart
  â†’ PostgreSQL & MinIO use named volumes â†’ ğŸ“¦ data and images still there
```

## 6) error handling (uniform UX)

```
Any backend failure
  â†’ raise BaseCustomException(status, user_message, internal_message)
  â‡¦ HTTP { detail: { user_message, internal_message } }
Angular catchError(...)
  â†’ show popup with user_message
  â†’ user must click close (no auto-dismiss)
```

---

# pipeline / testing lifeline

```
git push / MR
  â†’ .gitlab-ci.yml kicks off (both FE & BE):
     1) hello   : FE build / BE imports
     2) lint    : ESLint / Ruff
     3) test    : pytest (backend/tests/test_posts.py)
     4) format  : Prettier --check / Black --check
  â†’ any failure â†’ pipeline RED (blocks merge)

backend/tests/test_posts.py
  - test_default_username_anonymous()
  - test_list_returns_created()
  - test_vote_up_then_down_is_zero()
Live demo failing test: temporarily break repo.update_post_score() logic â†’ pytest fails â†’ revert
```

---

# â€œwhich file uses whichâ€ (quick dependency tree)

```
frontend/app.component.* 
  â””â”€ uses post.service.ts
        â””â”€ hits /post, /update-post-score, /image via proxy.conf.json

backend/main.py
  â”œâ”€ on startup â†’ db/database.create_tables()
  â”œâ”€ on startup â†’ dependencies.ensure_bucket()
  â”œâ”€ routes use â†’ Depends(get_service(PostService))
  â”‚      â””â”€ dependencies.get_service(...) builds PostService(PostRepository(db_session))
  â”‚              â”œâ”€ services/posts_service.py â†’ may call dependencies.get_minio()
  â”‚              â””â”€ repositories/post_repository.py â†’ uses db/database.SessionLocal engine
  â”œâ”€ validates with â†’ schemas/requests.py (Pydantic)
  â””â”€ raises â†’ core/exceptions.py (uniform error body)

db/models.py â†” repositories/post_repository.py (ORM mapping)
config.py â†’ supplies env vars to db/database.py & dependencies.py
```

---

# one-liners you can say to show mastery

* â€œ**Voting canâ€™t lose counts** because we update `score` **inside** a single SQL `UPDATE score = score + :inc`.â€
* â€œ**Images are content-addressed**: we hash the file (SHA-256) and store it in MinIO as `images/{hash}`; the DB stores only that hash.â€
* â€œWe **validate twice**: Angular for UX and Pydantic for guarantees (`title` required, â‰¤100). Username defaults to `anonymous` in frontend, schema, **and** DB.â€
* â€œ**Errors are consistent**: backend always returns `{detail:{user_message,...}}`, and our popup shows that message without auto-dismiss.â€
* â€œ**Persistence is via volumes**: Postgres rows and MinIO objects survive restarts; `create_tables()` and `ensure_bucket()` are idempotent.â€

---

if you want, i can tailor this to your exact filenames/paths (or add function signatures), but this should already be a clean, TA-ready, read-aloud â€œflowchart in text.â€
